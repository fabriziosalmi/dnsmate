"""BIND backup service for zone exports"""

import io
from typing import List, Dict, Any
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession

from app.services.powerdns import PowerDNSClient
from app.models.user import User


class BindBackupService:
    """Service for generating BIND-compatible zone file backups"""
    
    def __init__(self):
        self.powerdns = PowerDNSClient()
    
    async def generate_zone_backup(self, zone_name: str) -> str:
        """Generate BIND format backup for a single zone"""
        
        try:
            # Get zone and records data
            zone_data = await self.powerdns.get_zone(zone_name)
            records_data = await self.powerdns.get_records(zone_name)
            
            # Generate BIND zone file content
            bind_content = self._generate_bind_zone_file(zone_name, zone_data, records_data)
            
            return bind_content
            
        except Exception as e:
            raise ValueError(f"Failed to generate backup for zone {zone_name}: {str(e)}")
    
    async def generate_user_backup(self, user: User, zone_names: List[str]) -> str:
        """Generate BIND format backup for all user's zones"""
        
        backup_content = []
        backup_content.append(f"; BIND Backup generated on {datetime.utcnow().isoformat()}")
        backup_content.append(f"; User: {user.email}")
        backup_content.append(f"; Zones: {len(zone_names)}")
        backup_content.append(f"; Generated by DNSMate")
        backup_content.append("")
        
        for zone_name in zone_names:
            try:
                zone_backup = await self.generate_zone_backup(zone_name)
                backup_content.append(f"; Zone: {zone_name}")
                backup_content.append(f"; {'=' * 50}")
                backup_content.append(zone_backup)
                backup_content.append("")
                backup_content.append("")
                
            except Exception as e:
                backup_content.append(f"; ERROR: Failed to backup zone {zone_name}: {str(e)}")
                backup_content.append("")
        
        return "\n".join(backup_content)
    
    def _generate_bind_zone_file(
        self,
        zone_name: str,
        zone_data: Dict[str, Any],
        records_data: List[Dict[str, Any]]
    ) -> str:
        """Generate BIND zone file content"""
        
        content = []
        
        # Zone header
        content.append(f"; Zone file for {zone_name}")
        content.append(f"; Generated on {datetime.utcnow().isoformat()}")
        content.append(f"; Zone type: {zone_data.get('kind', 'Unknown')}")
        if zone_data.get('serial'):
            content.append(f"; Serial: {zone_data['serial']}")
        content.append("")
        
        # TTL directive
        default_ttl = 3600
        content.append(f"$TTL {default_ttl}")
        content.append("")
        
        # Origin directive
        if not zone_name.endswith('.'):
            zone_name = zone_name + '.'
        content.append(f"$ORIGIN {zone_name}")
        content.append("")
        
        # Process records by type for better organization
        records_by_type = {}
        for rrset in records_data:
            record_type = rrset.get('type', '')
            if record_type not in records_by_type:
                records_by_type[record_type] = []
            
            for record in rrset.get('records', []):
                records_by_type[record_type].append({
                    'name': rrset.get('name', ''),
                    'ttl': rrset.get('ttl', default_ttl),
                    'type': record_type,
                    'content': record.get('content', ''),
                    'disabled': record.get('disabled', False)
                })
        
        # Output records in a logical order
        record_order = ['SOA', 'NS', 'A', 'AAAA', 'CNAME', 'MX', 'TXT', 'SRV', 'PTR', 'CAA']
        
        for record_type in record_order:
            if record_type in records_by_type:
                content.append(f"; {record_type} Records")
                for record in records_by_type[record_type]:
                    if not record['disabled']:
                        line = self._format_bind_record(record, zone_name)
                        content.append(line)
                    else:
                        line = self._format_bind_record(record, zone_name)
                        content.append(f"; DISABLED: {line}")
                content.append("")
                del records_by_type[record_type]
        
        # Output any remaining record types
        for record_type, records in records_by_type.items():
            content.append(f"; {record_type} Records")
            for record in records:
                if not record['disabled']:
                    line = self._format_bind_record(record, zone_name)
                    content.append(line)
                else:
                    line = self._format_bind_record(record, zone_name)
                    content.append(f"; DISABLED: {line}")
            content.append("")
        
        return "\n".join(content)
    
    def _format_bind_record(self, record: Dict[str, Any], zone_name: str) -> str:
        """Format a single record in BIND format"""
        
        name = record['name']
        ttl = record['ttl']
        record_type = record['type']
        content = record['content']
        
        # Normalize the name
        if name == zone_name:
            name = "@"
        elif name.endswith(zone_name):
            name = name[:-len(zone_name)].rstrip('.')
        
        # Format based on record type
        if record_type == 'SOA':
            # SOA records need special formatting
            return f"{name:<20} {ttl:<8} IN {record_type:<8} {content}"
        elif record_type == 'MX':
            # MX records need priority
            parts = content.split(' ', 1)
            if len(parts) == 2:
                priority, target = parts
                return f"{name:<20} {ttl:<8} IN {record_type:<8} {priority} {target}"
            else:
                return f"{name:<20} {ttl:<8} IN {record_type:<8} 10 {content}"
        elif record_type == 'SRV':
            # SRV records have priority, weight, port, target
            return f"{name:<20} {ttl:<8} IN {record_type:<8} {content}"
        elif record_type == 'TXT':
            # TXT records should be quoted if they contain spaces
            if ' ' in content and not (content.startswith('"') and content.endswith('"')):
                content = f'"{content}"'
            return f"{name:<20} {ttl:<8} IN {record_type:<8} {content}"
        else:
            # Standard format for A, AAAA, CNAME, NS, etc.
            return f"{name:<20} {ttl:<8} IN {record_type:<8} {content}"
    
    def generate_named_conf_snippet(self, zone_names: List[str], zone_file_path: str = "/etc/bind/zones") -> str:
        """Generate named.conf snippet for the backed up zones"""
        
        content = []
        content.append("; named.conf snippet for DNSMate backed up zones")
        content.append(f"; Generated on {datetime.utcnow().isoformat()}")
        content.append("")
        
        for zone_name in zone_names:
            clean_zone_name = zone_name.rstrip('.')
            content.append(f'zone "{clean_zone_name}" {{')
            content.append('    type master;')
            content.append(f'    file "{zone_file_path}/{clean_zone_name}.zone";')
            content.append('    allow-transfer { any; };')
            content.append('    allow-query { any; };')
            content.append('};')
            content.append("")
        
        return "\n".join(content)
